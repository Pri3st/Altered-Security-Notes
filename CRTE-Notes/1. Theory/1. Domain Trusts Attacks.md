# 1. Overview
## Domain
- The Domain is the core unit of logical structure in [Active Directory](http://www.ihowd.com/what-is-active-directory). All objects that share a common directory database and trust relationship with other domain and security policies are known as Domains. Each domain stores information only about the objects that belong to that domain.
- All security polices and settings, such as administrative rights, security policies, and Access Control Lists (ACLs), do not cross from one domain to another. Thus, a domain administrator has full rights to set policies only within domain they belong to.
- Domains provide administrative boundaries for objects and manage security for shared resources and a replication unit for objects.
## Tree
- Trees are collections of one or more domains that allow global resource sharing. A tree may consist of a single domain or multiple domains in a contiguous namespace. A domain added to a tree becomes a child of the tree root domain. The domain to which a child domain is attached is called a parent domain. A child domain can also have its multiple child domains. Child domain uses the name then its parent domain name and gets a unique Domain Name System ([DNS](https://www.tech-faq.com/what-is-dns.html)).
- For example, if tech.com is the root domain, users can create one or more Child domains to tech.com such as north.tech.com and or south.tech.com. These “children” may also have child domains created under them, such as sales.north.tech.com.
- The domains in a tree have two way, Kerberos transitive trust relationships. A Kerberos transitive trust simply means that if Domain A trusts Domain B and Domain B trusts Domain C, then Domain A trusts Domain C. Therefore, a domain joining a tree immediately has trust relationships established with every domain in the tree.
## Forest
- A forest is a collection of multiple trees that share a common global catalog, directory schema, logical structure, and directory configuration. Forest has automatic two way transitive trust relationships. The very first domain created in the forest is called the forest root domain.
- Forests allow organizations to group their divisions that use different naming schemes and may need to operate independently. But as an organization, they want to communicate with the entire organization via transitive trusts and share the same schema and configuration container.
## Global Catalog
- The [global catalog is a partial copy of all objects](https://technet.microsoft.com/en-us/library/cc728188(v=ws.10).aspx) in an Active Directory forest, meaning that some object properties (but not all) are contained within it. This data is replicated among all domain controllers marked as global catalogs for the forest. One point of the global catalog is to allow for object searching and deconfliction quickly without the need for referrals to other domains ([more information here](https://technet.microsoft.com/en-us/library/cc978012.aspx)).
- The initial global catalog is generated on the first domain controller created in the first domain in the forest. The first domain controller for each new child domain is also set as a global catalog by default, but others can be added.
- The GC allows both users and applications to find information about any objects in ANY domain in the forest. GC is a feature that is enabled on a domain controller and performs the following functions:
	- Authentication (provided authorization for all groups that a user account belongs to, which is included when an access token is generated)
	- Object search (making the directory structure within a forest transparent, allowing a search to be carried out across all domains in a forest by providing just one attribute about an object.)

- A **[domain trust](http://technet.microsoft.com/en-us/library/cc759554(v=ws.10).aspx)** establishes the ability for users in one domain to authenticate to resources in another domain.
- Trusts allow organizations with multiple domains to grant users in separate domains access to shared resources. As Microsoft describes, “[_Most organizations that have more than one domain have a legitimate need for users to access shared resources located in a different domain_](http://technet.microsoft.com/en-us/library/cc757352(v=ws.10).aspx)“.
- [**Domain forests**](http://technet.microsoft.com/en-us/library/cc759073(v=ws.10).aspx#w2k3tr_logic_what_ovkc) are collections of domain containers that trust each other. Forests may also [have trusts](http://technet.microsoft.com/en-us/library/cc755700(v=ws.10).aspx) between them. Microsoft has an excellent post about [how domain and forest trusts work](http://technet.microsoft.com/en-us/library/cc773178(v=ws.10).aspx).
- A trust links up the authentication systems of two (or more) domains and allows authentication traffic to flow between them. This means that users from one domain can exist in groups on another domain and get rights to specific resources. Except for [enterprise admin](http://technet.microsoft.com/en-us/library/cc756898(WS.10).aspx), there is no inherent privileged access that comes with this relationship. An enterprise admin is an administrator for ALL domains in a forest. This means an enterprise admin in a parent domain automatically has domain administrator access in all of its child domains.
- Essentially, all a trust does is link up the authentication systems of two domains and allows authentication traffic to flow between them through a system of referrals.
- **If a user requests access to a service principal name (SPN) of a resource that resides outside of the domain they’re current in, their domain controller will return a special referral ticket that points to the key distribution center (KDC, in the Windows case the domain controller) of the foreign domain. The user’s ticket-granting-ticket (TGT) is included in this TGS-REP (ticket-granting service reply) referral ticket, and this ticket encrypted/signed with the inter-realm trust key that the domains previously exchanged, instead of the first domain’s krbtgt account. This ticket is usually referred to as an “inter-realm ticket-granting-ticket/TGT.” The foreign domain then verifies/decrypts the TGT included in the referral by decrypting it with the previously negotiated inter-realm trust key, and goes about the rest of the normal Kerberos process.**
- **Once there is a trust between two domains … the ticket-granting service of each domain (“realm” in Kerberos speak) is registered as a security principal with the other domain’s Kerberos service (KDC). This enables the ticket-granting service in each domain to treat the one in the other domain as just another service providing cross-domain service access for resources in the other domain. So basically, when the foreign domain decrypts the referral ticket with the negotiated trust key, it sees the user’s TGT and says “_OK, the other domain already authenticated this user and said this is who they say they are/these are the groups the user is in, so I’ll trust this information as accurate because I trust the domain that issued the referral.”_**
![[trust_auth_flow.webp]]
- The purpose of establishing a trust is to allow users from one domain to access resources (like the local Administrators group on a server), to be nested in groups, or to otherwise be used as security principals in another domain (e.g. for AD object ACLs). One exception to this is intra-forest trusts (domain trusts that exist within the same Active Directory forest)- any domain created within a forest retains an implicit two-way, transitive trust relationship with every other domain in the forest.
# 2. Trust Types
- **Parent/Child** — part of the same forest — a child domain retains an implicit two-way transitive trust with its parent. This is probably the most common type of trust that you’ll encounter.
- **Cross-link** — aka a “shortcut trust” between child domains to improve referral times. Normally referrals in a complex forest have to filter up to the forest root and then back down to the target domain, so for a geographically spread out scenario, cross-links can make sense to cut down on authentication times.
- **External** — an implicitly non-transitive trust created between disparate domains. “[_External trusts provide access to resources in a domain outside of the forest that is not already joined by a forest trust._](https://technet.microsoft.com/en-us/library/cc773178(v=ws.10).aspx)” External trusts enforce SID filtering, a security protection covered later in this post.
- **Tree-root** — an implicit two-way transitive trust between the forest root domain and the new tree root you’re adding. From the [Microsoft documentation](https://technet.microsoft.com/en-us/library/cc773178(v=ws.10).aspx), they’re created when you when you create a new domain tree in a forest. These are intra-forest trusts, and they [preserve two-way transitivity](https://technet.microsoft.com/en-us/library/cc757352(v=ws.10).aspx) while allowing the tree to have a separate domain name (instead of child.parent.com).
- **Forest** — a transitive trust between one forest root domain and another forest root domain. Forest trusts also enforce SID filtering.
- **MIT** — a trust with a non-Windows [RFC4120-compliant](https://tools.ietf.org/html/rfc4120) Kerberos domain.
# 3. Direction of Trust & Direction of Access
- There are one-way and two-way trusts. A one-way trust means users and computers in a _trusted domain_ can access resources in another _trusting domain_. A one-way trust is one way only [hence the name]. Users and computers in the trusting domain can not access resources in the trusted domain.
![[one_way_trust.gif]]
- A two-way trust means that users and computers in both domains can access resources in each other. Within a forest, each domain has a two-way transitive trust with both its parent an each of its children.
- Trusts are transitive or non-transitive, “[_A transitive trust extends trust relationships to other domains; a nontransitive trust does not extend trust relationships to other domains._](http://technet.microsoft.com/en-us/library/cc759554(v=ws.10).aspx)” This means that transitive trusts can be chained, so users can potentially access resources in multiple domains.
- When a trust is present between domains, privileged accounts in one domain may have access to systems in another domain that trusts it. I say “may” because administrators need to go an extra step and enable privileged access. Fortunately for attackers, many enterprise environments with trusts enable these privileges. An attacker may focus their efforts to compromise accounts or machines in one domain and leverage that trust to take systems in another domain.
- Even without privileged access, a domain trust relationship allows you to query users, machines, and more information between domains. A savvy attacker may use this information to better plan an attack against targets in the other domain.
- Another nice side effect for attackers is that the domain controllers for domains with a trust MUST be able to talk to each other. If you can’t reach a target domain, but your current domain has a trust with the target, hop to one of your current DCs and you should have access.
# 4. A Trust Attack Strategy
1. The first step is to enumerate all trusts your current domain has, along with any trusts _those_ domains have, and so on. Basically, you want to produce a mapping of all the domains you can reach from your current context through the linking of trust referrals. This will allow you to determine the domains you need to hop through to get to your target and what techniques you can execute to (possibly) achieve this. Any domains in the mapped “mesh” that are in the same forest (e.g. parent->child relationships) are of particular interest due to the SIDhistory-trust-hopping technique.
2. The next step is to enumerate any users/groups/computers (security principals) in one domain that either (1) have access to resources in another domain (i.e. membership in local administrator groups, or DACL ACE entries), or (2) are in groups or (if a group) have users from another domain. The point here is to find relationships that cross the mapped trust boundaries in some way, and therefore might provide a type of “access bridge” from one domain to another in the mesh. While a cross-domain nested relationship is not guaranteed to facilitate access, trusts are normally implemented for a reason, meaning more often than not some type of cross-domain user/group/resource “nesting” probably exists, and in many organizations these relationships are misconfigured. Another subnote- as mentioned, Kerberoasting across trusts **may** be another vector to hop a trust boundary.
3. Now that you have mapped out the trust mesh, types, and cross-domain nested relationships, you have a map of what accounts you need to compromise to pivot from your current domain into your target.
4. At a minimum, remember that if a domain trusts you, i.e. if the trust is bidirectional or if one-way and inbound, then you can query any Active Directory information from the _trusting_ domain. And remember that all parent->child (intra-forest domain trusts) retain an implicit two way transitive trust with each other. Also, due to how child domains are added, the “Enterprise Admins” group is automatically added to Administrators domain local group in each domain in the forest. This means that trust “flows down” from the forest root, making it our objective to move from child to forest root at any appropriate step in the attack chain.
# 5. Enumerating Trusts
### Methods
- There are three main methods to enumerate trusts: Win32 API calls, various .NET methods, and LDAP. Each one (frustratingly) returns a differing set of information, and each one has different execution methods.
#### 1) .NET Methods
- .NET provides us with some nice method wrappers that can enumerate a good chunk of domain and forest trust information. This was the first method that PowerView implemented, before branching into Win32 API and LDAP methods.
- The [System.DirectoryServices.ActiveDirectory.Domain] namespace has a [GetCurrentDomain()](https://msdn.microsoft.com/en-us/library/system.directoryservices.activedirectory.domain.getcurrentdomain(v=vs.110).aspx) static method that returns a [System.DirectoryServices.ActiveDirectory.Domain](https://msdn.microsoft.com/en-us/library/system.directoryservices.activedirectory.domain(v=vs.110).aspx) class instance. This class implements the [GetAllTrustRelationships()](https://msdn.microsoft.com/en-us/library/system.directoryservices.activedirectory.domain.getalltrustrelationships(v=vs.110).aspx) method which nicely, “_Retrieves all of the trust relationships for this domain._” One advantage of this method is its simplicity — the information is laid out in a fashion that is easy to read and understand. One disadvantage is that it doesn’t contain some of the additional information that other enumeration methods produce.
```([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()```
- This used to be PowerView’s default **Get-DomainTrust** enumeration method. In order to execute this method, you now need to run:
`Get-DomainTrust -NET`
- Forest trusts are functionally different than domain trusts. So if you want to enumerate any current forest->forest trusts, you need to call on [[System.DirectoryServices.ActiveDirectory.Forest]](https://msdn.microsoft.com/en-us/library/system.directoryservices.activedirectory.forest(v=vs.110).aspx) instead. Resulting forest objects also have their own [GetAllTrustRelationships()](https://msdn.microsoft.com/en-us/library/system.directoryservices.activedirectory.forest.getalltrustrelationships(v=vs.110).aspx) method which will return any current forest trusts:
```([System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()).GetAllTrustRelationships()```
- This is implemented as the default enumeration methods for PowerView’s **Get-ForestTrust** function.
#### 2) Win32API
- You can also enumerate domain trusts through the [DsEnumerateDomainTrusts()](https://msdn.microsoft.com/en-us/library/ms675976(v=vs.85).aspx) Win32 API call which returns a [DS_DOMAIN_TRUSTS](https://msdn.microsoft.com/en-us/library/ms676059(v=vs.85).aspx) structure. While the information is a bit more complex than the .NET methods, it returns the SID and GUID of the target domain, as well as some useful flags and attributes. The flags are [documented here](https://msdn.microsoft.com/en-us/library/ms675976(v=vs.85).aspx) and will tell you the trust direction, whether the trust is within the same forest, etc. The attributes are [documented here](https://msdn.microsoft.com/en-us/library/ms722477(v=vs.85).aspx) under the **TrustAttributes** specification, and include things like WITHIN_FOREST, NON_TRANSITIVE, FILTER_SIDS, and more. FILTER_SIDS is the equivalent of QUARANTINED_DOMAIN if you ever see that nomenclature.
- You can invoke this method with:
`Get-DomainTrust -API`
- This appears to be what **nltest.exe** uses with its **/trusted_domains** flag.
- This is also the [method that BloodHound uses](https://github.com/BloodHoundAD/SharpHound/blob/b2f98dc9e5675b5687964a7eaeeb3573fe6b676a/Sharphound2/Enumeration/DomainTrustEnumeration.cs#L140-L143) to enumerate domain trusts. You can execute this with the new [SharpHound.ps1](https://github.com/BloodHoundAD/BloodHound/blob/master/Ingestors/SharpHound.ps1) ingestor by using the **Invoke-BloodHound -CollectionMethod trusts** syntax. Note that this can also be combined with **-Domain <foreign.domain.fqdn>** for foreign trust enumeration as well.
#### 3) LDAP
- Domain trusts are stored in Active Directory as “trusted domain objects” with an objectClass of [**trustedDomain**](https://msdn.microsoft.com/en-us/library/ms683977(v=vs.85).aspx). This means you can use whatever LDAP querying method you would like to find out information about any domain trusts that are present by using the LDAP filter **(objectClass=trustedDomain)**.
- For example, here’s dsquery (only available on Windows servers):
```dsquery * -filter “(objectClass=trustedDomain)” -attr *```
- The equivalent syntax with [Joeware’s Adfind](http://www.joeware.net/freetools/tools/adfind/) is **.\adfind.exe -f objectclass=trusteddomain**.
And finally PowerView, which again now uses this LDAP as the default enumeration method for:
`Get-DomainTrust`
### Result Properties - SUPER IMPORTANT
- All of these methods can also be executed against a domain that currently trusts you. Meaning, if your current domain has a bidirectional trust with FOREIGN domain, or if the trust is one-way and inbound (meaning said domain trusts you and therefore you have some kind of access), you can execute these methods against said domain to find the trusts for THAT domain. If you want to do this with PowerView, just supply the **-Domain <domain.fqdn>** parameter.
[TrustType](https://msdn.microsoft.com/en-us/library/cc223771.aspx):
- **DOWNLEVEL** (0x00000001) — a trusted Windows domain that IS NOT running Active Directory. This is output as **WINDOWS_NON_ACTIVE_DIRECTORY** in PowerView for those not as familiar with the terminology.
- **UPLEVEL** (0x00000002) — a trusted Windows domain that IS running Active Directory.This is output as **WINDOWS_ACTIVE_DIRECTORY** in PowerView for those not as familiar with the terminology.
- **MIT** (0x00000003) — a trusted domain that is running a non-Windows (*nix), RFC4120-compliant Kerberos distribution. This is labeled as MIT due to, well, MIT publishing RFC4120.

[TrustAttributes](https://msdn.microsoft.com/en-us/library/cc223779.aspx):
- **NON_TRANSITIVE** (0x00000001) — the trust cannot be used transitively. That is, if DomainA trusts DomainB and DomainB trusts DomainC, then DomainA does not automatically trust DomainC. Also, if a trust is non-transitive, then you will not be able to query any Active Directory information from trusts up the chain from the non-transitive point. External trusts are implicitly non-transitive.
- **UPLEVEL_ONLY** (0x00000002) — only Windows 2000 operating system and newer clients can use the trust.
- **QUARANTINED_DOMAIN** (0x00000004) — SID filtering is enabled (more on this later). Output as **FILTER_SIDS** with PowerView for simplicity.
- **FOREST_TRANSITIVE** (0x00000008) — cross-forest trust between the root of two domain forests running at least domain functional level 2003 or above.
- **CROSS_ORGANIZATION** (0x00000010) — the trust is to a domain or forest that is not part of the organization, which adds the OTHER_ORGANIZATION SID. This is a bit of a weird one. I don’t remember encountering this flag in the field, but according [to this post](https://imav8n.wordpress.com/2008/07/30/trust-attribute-cross_organization-and-selective-auth/) it means that the selective authentication security protection is enabled. For more information, check out [this MSDN doc](https://technet.microsoft.com/en-us/library/cc755321(v=ws.10).aspx#w2k3tr_trust_security_zyzk).
- **WITHIN_FOREST** (0x00000020) — the trusted domain is within the same forest, meaning a parent->child or cross-link relationship
- **TREAT_AS_EXTERNAL** (0x00000040) — the trust is to be treated as external for trust boundary purposes. According [to the documentation](https://msdn.microsoft.com/en-us/library/cc223779.aspx), “_If this bit is set, then a cross-forest trust to a domain is to be treated as an external trust for the purposes of SID Filtering._ **_Cross-forest trusts are more stringently filtered than external trusts_**_. This attribute relaxes those cross-forest trusts to be equivalent to external trusts._” 
- **USES_RC4_ENCRYPTION** (0x00000080) — if the TrustType is MIT, specifies that the trust that supports RC4 keys.
- **USES_AES_KEYS** (0x00000100) — not listed in the linked Microsoft documentation, but according to [some documentation](http://krbdev.mit.edu/rt/Ticket/Display.html?id=5477) I’ve been able to [find online](https://retep998.github.io/doc/winapi/ntsecapi/constant.TRUST_ATTRIBUTE_TRUST_USES_AES_KEYS.html), it specifies that AES keys are used to encrypt KRB TGTs.
- **CROSS_ORGANIZATION_NO_TGT_DELEGATION** (0x00000200) — “[_If this bit is set, tickets granted under this trust MUST NOT be trusted for delegation._](https://msdn.microsoft.com/en-us/library/cc223779.aspx)” This is described more in [[MS-KILE] 3.3.5.7.5](https://msdn.microsoft.com/en-us/library/cc233949.aspx) (Cross-Domain Trust and Referrals.)
- **PIM_TRUST** (0x00000400) — “[_If this bit and the TATE (treat as external) bit are set, then a cross-forest trust to a domain is to be treated as Privileged Identity Management trust for the purposes of SID Filtering._](https://msdn.microsoft.com/en-us/library/cc223779.aspx)” According to [[MS-PAC] 4.1.2.2](https://msdn.microsoft.com/en-us/library/cc237940.aspx) (SID Filtering and Claims Transformation), “[_A domain can be externally managed by a domain that is outside the forest. The trusting domain allows SIDs that are local to its forest to come over a PrivilegedIdentityManagement trust._](https://msdn.microsoft.com/en-us/library/cc237940.aspx)”.
### Data Enumeration Across Trusts With PowerView
- Any **Get-Domain*** function uses LDAP enumeration, meaning that we can pull said information from a domain that trusts us. This is done with the **-Domain <domain.fqdn>** parameter.
- What actually happens is that a referral is returned by the domain controller you are currently communicating with, which instructs your searching method to then bind to the foreign domain (i.e. the primary domain controller/PDC for that domain). If there is a trust with the foreign domain, an inter-realm TGT will be returned that can be used when communicating to the foreign domain. **This means that if there is network segmentation between the computer you’re currently querying from, and the PDC for the trusting domain, you won’t be able to retrieve any results.**
- From the Kerberos side, “under the hood”, this means that a series of inter-realm referral tickets are automatically issued that allow our user to eventually request an LDAP service ticket from the target domain.
### Mapping Domain Trusts
- There are few ways I know of to map the “mesh” of one or more trusts that exist in your environment.
- The first is through the global catalog. The [global catalog is a partial copy of all objects](https://technet.microsoft.com/en-us/library/cc728188(v=ws.10).aspx) in an Active Directory forest, meaning that some object properties (but not all) are contained within it. This data is replicated among all domain controllers marked as global catalogs for the forest. Trusted domain objects are replicated in the global catalog, so we can enumerate every single internal and external trust that all domains in our current forest have extremely quickly, and only with traffic to our current PDC by running **Get-DomainTrust -SearchBase “GC://$($ENV:USERDNSDOMAIN)”** through PowerView.
- The second method is slower, but will provide even more results. Since we can enumerate any trusts that our current domain context has, and by way of referrals through LDAP, we can query any **(objectClass=trustedDomain)** objects from domains that currently trust our domain, then we can keep issuing these queries for any results and “crawl” any reachable domains. Any domains marked as non-transitive can mess these results up, but we can still get a good number of results. The PowerView function to do this is **Get-DomainTrustMapping** (formerly Invoke-MapDomainTrust). These results can be exported to a CSV by piping **Get-DomainTrustMapping** to **| Export-CSV -NoTypeInformation trusts.csv**.
- The last way is through BloodHound/SharpHound. Again, you can execute this with the new [SharpHound.ps1](https://github.com/BloodHoundAD/BloodHound/blob/master/Ingestors/SharpHound.ps1) ingestor by using the **Invoke-BloodHound -CollectionMethod trusts** syntax, and this can be combined with **-Domain <foreign.domain.fqdn>** for foreign trust enumeration.
- A key thing to remember is that the exact trust mapping you’ll get will depend on the domain you’re currently in. Since the trust between **external.local** and **sub.dev.testlab.local** domain is a one-way _non-transitive_ external trust, if you’re querying from **external.local** you won’t be able to see the trusts that **contoso.local** has, again because **sub.dev.testlab.local** won’t repackage your TGT into an inter-realm TGT that can be forwarded onto any other domain. Also, if you’re trying to enumerate the trusts on a foreign domain, you need to be able to bind to a domain controller (usually the PDC/primary domain controller) in the foreign domain you’re querying. So, even if there is a transitive trust that would allow you to query the information, if network segmentation prevents you from talking to the target foreign domain, you’re out of luck.
## Visualizing Domain Trusts
- We can easily visualize domain trusts using [TrustVisualiser](https://github.com/Pri3st/TrustVisualizer).
# 6. Foreign Relationship Enumeration
- Now that we’ve mapped out all domain trusts reachable from the machine we’re querying from, the next step in the attack planning phase hits few branches, depending on the specific types of the trusts we’ve encountered. These next steps need to be executed for the hop from each each domain to another in the attack path.
- If the next domain hop is in the same forest as the domain we’re pivoting from/through, **_and_** we’re able to compromise the `krbtgt` hash of the child domain, then we can compromise the forest root.
- If we’re not able to compromise elevated access in the current/pivot child domain, or if the next step in the trust attack path is an external/forest trust, then we need to enumerate what users (if any) from the domain we’re a part of are in groups in the target domain (or the next step in the domain attack path.)
- Unfortunately, there are a lot of caveats with this step. The exact nature of the trust your current domain retains with the _trusting_ domain you’re querying will affect what information you can retrieve, and the exact methods you can use. In general, again, this enumeration heavily depends on whether you’re querying a foreign domain in the same forest, or across an external/inter-forest trust.
- There are three **main** ways that security principals (users/groups) from one domain can have access into resources in another foreign/_trusting_ domain:
	- They can be added to local groups on individual machines, i.e. the local “Administrators” group on a server.
	- They can be added to groups in the foreign domain. There are some caveats depending on trust type and group scope.
	- They can be added as principals in an access control list, most interesting for us as principals in ACEs in a DACL. For more background on ACLs/DACLs/ACEs, check out the “[An ACE Up The Sleeve](https://specterops.io/assets/resources/an_ace_up_the_sleeve.pdf)” whitepaper.
## Case 1: Local Group Membership
- This involves enumerating the local memberships of one or more systems through remote SAM (SAMR) or [through GPO correlation](http://www.harmj0y.net/blog/redteaming/where-my-admins-at-gpo-edition/). The PowerView function to do this manually is:
`Get-NetLocalGroupMember <server>`.
- BloodHound will do this all automatically for you.
## Case 2: Foreign Group Membership
- The group membership case gets a bit tricky. The **member** property of an Active Directory group and the **memberOf** property of a user/group object have a special type of relationship called [linked attributes](https://msdn.microsoft.com/en-us/library/ms677270(v=vs.85).aspx). With linked attributes, Active Directory calculates the value of a given attribute, referred to as the back link (e.g. **memberOf** with users/groups) from the value of another attribute, referred to as the forward link (e.g. **member** with a group). The gist is that group membership is ultimately preserved within the target group itself in the **member** property, and this all gets a bit complicated over trusts. Whether or not the **memberOf** property saved with a user/group object reflects their foreign group memberships depends on the nature of the trust and scoping of the foreign group they’re a member in.
- Here’s a breakdown of the three group scopings, and which can have what type of foreign members added:
	- **Domain Local Groups** can have intra-forest cross-domain users (users in the same forest as the group) added as members, as well as inter-forest cross-domain users (foreign security principals.)
	- **Global Groups** can not have any cross-domain memberships, even within the same forest. So for our purposes we can ignore these.
	- **Universal Groups** can have any user in the forest as a member, but “foreign security principals” (i.e. users from forest/external trusts) can not be a part of universal groups.
- If a user/group is nested into a group in another domain that’s in the same forest (so a “domain local” or “universal group”) then depending on [the target group’s scope](http://www.harmj0y.net/blog/activedirectory/a-pentesters-guide-to-group-scoping/) the membership _might_ be updated in the user/group’s **memberOf** property. Groups with a “universal” scope have their memberships replicated in the global catalog for the forest, meaning a user’s **memberOf** will be updated. If the group’s scope the user is added to is “domain local”, then the user’s **memberOf** will NOT be updated (in the global catalog), as a group with “domain local” scope does not have its memberships replicated in the forest. So the only way to tell what a user’s foreign group memberships are, by solely looking at the user object, is if they are added to a universal group in the same forest. However, this also means that if we can bind to the global catalog of a forest, we can enumerate all of these specific cross-domain relationships easily.
- If the user is nested in a group in a domain over a forest/external trust, then things are treated a bit differently. Users that exist over external or forest trusts can still be added to [**domain local**](http://www.harmj0y.net/blog/activedirectory/a-pentesters-guide-to-group-scoping/) groups in the specified domain. These users show up as new entries in **CN=ForeignSecurityPrincipals,DC=domain,DC=com** in the domain to which they’re being added, which are used as a kind of proxy that allows the foreign security identifiers to be added to resources in the domain.
- As Microsoft explains it, “[_When a trust is established between a domain in a forest and a domain outside of that forest, security principals from the external domain can access resources in the internal domain. Active Directory creates a foreign security principal object in the internal domain to represent each security principal from the trusted external domain. These foreign security principals_ **_can become members of domain local groups_** _in the internal domain_](https://technet.microsoft.com/en-us/library/cc773178(v=ws.10).aspx)“. If “domain local” or “group scoping” are foreign to you, check out my [previous post on the subject](http://www.harmj0y.net/blog/activedirectory/a-pentesters-guide-to-group-scoping/).
- These ForeignSecurityPrincipals act as aliases for the “real” user that’s external to the domain/forest, and it’s the ForeignSecurityPrincipal that’s actually added to groups in the target domain. The SID of a given ForeignSecurityPrincipal is the same SID as the foreign user, which makes for easy filtering later.
## Case 3: Foreign ACL Principals
- Luckily most of the **ntSecurityDescriptor** property of Active Directory objects is (1) accessible to any domain authenticated user, and (2) replicated in the global catalog. This means that if from your current domain context, you can query the DACLs for all objects in a _trusting_ domain, and filter any ACE entries where a foreign security principal has the given right on the object you’re enumerating.
- You can use PowerView’s **Get-DomainObjectACL -Domain <domain.fqdn>** function to retrieve these ACEs, but in order to find cross-domain DACL relationships, you will need to filter out principals/SecurityIdentifiers that do not match the SID of the domain you’re querying.
# 7. Operational Guidance
- If you’re currently within a child domain within a forest, and _DO NOT_ have elevated access in said child domain, then you can run PowerView’s **Get-DomainForeignUser** function to enumerate users who are in groups outside of the user’s current domain. This is a domain’s “outgoing” access, i.e. users/groups who may have some kind of access into other domain groups _within the same forest._ This function can be useful to also map other intra-forest domain user/group relationships.
- If you’re targeting an external/forest domain, or a target domain within the same forest, you can use PowerView’s **Get-DomainForeignGroupMember -Domain <target.domain.fqdn>** function. This enumerates _groups_ in the target domain that contain _users/groups_ who are not in the target domain. This is a domain’s “incoming” access, i.e. groups in target domain with inbound membership relationships.
- Also, luckily for us, ForeignSecurityPrincipals are replicated in the global catalog, just like trusted domain objects (mentioned in the **Mapping Domain Trusts** section). So if you want to quickly enumerate all foreign security principals (i.e. any inbound foreign groups/users) that are members of groups within a domain within the current/target forest, you can query any global catalog with an LDAP filter of **‘(objectclass=foreignSecurityPrincipal)’**. And since these foreign principals can only be added to groups with a [domain local scope](http://www.harmj0y.net/blog/activedirectory/a-pentesters-guide-to-group-scoping/), we can extract the domain the foreign user was added to from the distinguishedname, query that domain directly for domain local-scoped groups with members, assuming we have some type of direct or transitive trust with that target domain. This allows us to compare the membership of these domain local groups each against the list of foreign users:
```powershell
$ForeignUsers = Get-DomainObject -Properties objectsid,distinguishedname -SearchBase "GC://sub.dev.testlab.local" -LDAPFilter '(objectclass=foreignSecurityPrincipal)' | ? {$_.objectsid -match '^S-1-5-.*-[1-9]\d{2,}$'} | Select-Object -ExpandProperty distinguishedname
$Domains = @{}
 
$ForeignMemberships = ForEach($ForeignUser in $ForeignUsers) {
    # extract the domain the foreign user was added to
    $ForeignUserDomain = $ForeignUser.SubString($ForeignUser.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'
    # check if we've already enumerated this domain
    if (-not $Domains[$ForeignUserDomain]) {
        $Domains[$ForeignUserDomain] = $True
        # enumerate all domain local groups from the given domain that have any membership set
        Get-DomainGroup -Domain $ForeignUserDomain -Scope DomainLocal -LDAPFilter '(member=*)' -Properties distinguishedname,member | ForEach-Object {
            # check if there are any overlaps between the domain local groups and the foreign users
            if ($($_.member | Where-Object {$ForeignUsers  -contains $_})) {
                $_
            }
        }
    }
}
 
$ForeignMemberships | fl
```
- This quickly gives us a mapping of all the foreign user/group nested relationships inbound into our current (or target) forest.
- If you are using [BloodHound](https://github.com/BloodHoundAD/BloodHound/) with its new [SharpHound](https://github.com/BloodHoundAD/BloodHound/blob/master/Ingestors/SharpHound.ps1) ingestor, you can still use **-Domain <domain.fqdn>** with the ingestor combined with the **-CollectionMethod** options of ‘Group’, ‘LocalGroup’, and/or ‘ACL’. BloodHound models user/group nodes with the **name@<domain.fqdn>** syntax in the schema. This removes the requirement of having to perform complex analytics to extract these relationships after the data has been collected. If **user@dev.testlab.local** is a member of **group@testlab.local**, that memberOf relationship is automatically modeled. If that nested group relationship shows up in any attack paths, it will be automatically included in your graph with no extra effort.
# 8. Trustpocalypse — SID Hopping Up Intra-Forest Cross-Domain Trusts
- Microsoft has stated for years that “[_the forest is the security boundary for Active Directory_](https://technet.microsoft.com/en-us/library/cc755979(v=ws.10).aspx)“, and an attack against intra-forest domains [has been known since (at least) 2005](http://windowsitpro.com/windows-server/exploiting-sidhistory-ad-attribute).
- **sidHistory** was added with Windows 2000 Active Directory, and was meant to facilitate the migration of users from one domain to another. If a user is migrated, their old security identifier (SID), along with the SIDs of any group they were previously a part of, can optionally be added to the `sidHistory` attribute of their new user account. When the new user attempts to access a resource, “[_if the SID or the SID history matches, access to the resource is granted or denied, according to the access specified in the ACL._](https://technet.microsoft.com/en-us/library/cc974408(v=ws.10).aspx)” Meaning, any group/old user SID that is set in a user’s sidHistory property grants them access _as if they were that user or a member of those groups_.
- Due to how trusts work within an Active Directory forest, the **sidHistory** property (“ExtraSids” in the PAC) is respected within the domains of a forest because those SIDs are not filtered out in cross-domain referrals by the “SID Filtering” protection. So any user in a child domain that has their **sidHistory**/**ExtraSids** set to, say, the “Enterprise Admins” SID (a group that exists only in the forest root) will effectively function _as if they are an enterprise administrator_. As Microsoft has known this is an issue, and the knowledge has been public since at least this [2005 ITPro Windows article](http://windowsitpro.com/windows-server/exploiting-sidhistory-ad-attribute) and almost certainly before, **sidHistory** is a protected attribute that is extremely difficult to modify.
- **THIS IS WHY THE FOREST IS THE “TRUST BOUNDARY” IN ACTIVE DIRECTORY, NOT THE DOMAIN!**
- With the introduction of Mimikatz’ Golden Tickets, an attacker could set the **ExtraSids** section of the [KERB_VALIDATION_INFO](https://msdn.microsoft.com/en-us/library/cc237948.aspx) structure created for the ticket (the structure that “[_defines the user’s logon and authorization information provided by the DC_](https://msdn.microsoft.com/en-us/library/cc237948.aspx)“). The **ExtraSids** section is described as “[_A pointer to a list of KERB_SID_AND_ATTRIBUTES structures that contain a list of SIDs corresponding to groups in domains other than the account domain to which the principal belongs_](https://msdn.microsoft.com/en-us/library/cc237948.aspx)” (the KERB_SID_AND_ATTRIBUTES structure [is defined here](https://msdn.microsoft.com/en-us/library/cc237947.aspx).)
- This means that if an attacker compromises “Domain Administrator” rights (or equivalent, actually just any account that can DCSync ;) in ANY child domain in the forest for just 5 minutes, the krbtgt hash of the child domain can be retrieved, and **/sids:<sid_of_enterprise_admins_in_forest_root>** can be added to the Mimikatz constructed ticket without modifying the Active Directory database. This gives the attacker the ability to “hop up” the forest trust relationship and compromise the forest root domain.
- If we are currently in a child domain and can compromise DCSync/DA access, or if we can compromise this level of access in any child domain along our attack chain, we can forgo the burdensome foreign relationship enumeration to hop up the trust to instantly compromise the forest root.
- This will only work for hopping between trusts **_within_** **_a forest_**. This will not work for external or inter-forest trusts due to SID filtering.
# 9. A Case Study
- Consider again the sample trust diagram:
![[case_study.webp]]
- Say we land an account in **external.local**. Since **sub.dev.testlab.local** _trusts_ **external.local**, **external.local** can query information from **sub.dev.testlab.local**, while SUB cannot do the same to EXTERNAL. From the external context, we can query the trusts that SUB has.
- But this only returns the direct trusts that **sub.dev.testlab** has with other domains (**dev.testlab.local** and **external.local**). If we can query the global catalog (not always possible) from **sub.dev.testlab** and return all domain trusts in the entire forest!
- Note that because since this is a one-way, non-transitive external trust into **sub.dev.testlab.local**, we can’t query the trusts that **contoso.local** has from the EXTERNAL context, as our Kerberos traffic will not be properly referred.
- So, from here we would then run **Get-DomainForeignGroupMember -Domain sub.dev.testlab.local** to see if any groups in SUB contained members in EXTERNAL.
- From there, we would attempt targeted account compromise to hop the trust into **sub.dev.testlab.local**. The **Get-DomainForeignUser** command would be of no use here, due to the caveats about linked-value replication and trusted.
- However, because **external.local -> sub.dev.testlab.local** is an external trust relationships, it is implicitly non-transitive, so couldn’t query the domain local group memberships of **dev.testlab.local** or **testlab.local**.
- If we were then able to compromise domain admin (or equivalent) credentials in **sub.dev.testlab.local**, we could build a sidHistory-trust-hopping Golden Ticket as described in the “**Trustpocalypse**” section to compromise the **testlab.local** forest root domain. If we weren’t able to procure elevated access, we would run **Get-DomainForeignUser** to see if any users from **sub.dev.testlab.local** had access into other groups in the forest. Again, remember the previous information about scoping- only _universal_ group memberships will be reflected here.
- We would also run **Get-DomainForeignGroupMember -Domain dev.testlab.local** and **Get-DomainForeignGroupMember -Domain testlab.local** to see that groups in those other forest domains had “incoming” access.
- Once/if we were able to compromise part or all of the **testlab.local** forest root through either of the previous approaches, we would then run **Get-DomainForeignGroupMember -Domain contoso.local** and **Get-DomainForeignGroupMember -Domain prod.contoso.local** to see if there were any users in the TESTLAB forest that had foreign group membership in the CONTOSO forest.
- Along the way, we would could run **Get-NetLocalGroupMember <foreign,server>** against a targeted selection of servers (including DCs) to see if any users crossed the boundary that way via machine local groups. We could also use targeted **Get-DomainObjectACL -Domain <foreign.domain>** with various filters to check for foreign ACL memberships.
- Or we could just pull everything with BloodHound, and rely on the schema to model the cross-forest hops.
# 10. Forging Inter-Realm Trust Tickets
- If we can retrieve the hash of the inter-realm trust key, a referral ticket can be forged ([as Sean describes](https://adsecurity.org/?p=1588)) that allows us to pretend to be any user from the first domain when requesting access to the second domain. This hash retrieval can be done through normal password dumping or through DCSync, by querying the **FOREIGN_DOMAIN_SHORTNAME$** account.
- However, if we can retrieve the inter-realm trust key, then in pretty much all cases we can pull the krbtgt hash of the referring domain. If we have this, we can construct a ticket for user referring domain, pretending to be any user we want to the foreign domain.
- There is one specific instance where it gets interesting. Say an organization rotates the passwords for _every_ elevated account in _every_ domain in the forest, are they safe? Well, while inter-realm trust keys automatically rotate every 30 days according to section [6.1.6.9.6.1 of the Active Directory Technical Specification](https://msdn.microsoft.com/en-us/library/cc223791.aspx), they aren’t rotated when the krbtgt account changes. So if an attacker has the inter-realm keys in their possession, they can still use the sidHistory approach to hop up a trust, [as Sean details](https://adsecurity.org/?p=1588).
# 11. Kerberoasting Across Domain Trusts
- When using .NET’s [System.IdentityModel.Tokens.KerberosRequestorSecurityToken](https://msdn.microsoft.com/en-us/library/system.identitymodel.tokens.kerberosrequestorsecuritytoken(v=vs.110).aspx) class (and then its [.GetRequest()](https://msdn.microsoft.com/en-us/library/system.identitymodel.tokens.kerberosrequestorsecuritytoken.getrequest(v=vs.110).aspx) method), we specify a service principal name (SPN) to request a TGS-REP for, and subsequently use the [GetRequest()](https://msdn.microsoft.com/en-us/library/system.identitymodel.tokens.kerberosrequestorsecuritytoken.getrequest(v=vs.110).aspx) to retrieve the bytes for the AP-REQ that’s intended to be sent to the target service. This AP-REQ contains the service ticket that we then extract and use for offline Kerberoasting/password cracking.
- The documentation for the [KerberosRequestorSecurityToken.ServicePrincipalName](https://msdn.microsoft.com/en-us/library/system.identitymodel.tokens.kerberosrequestorsecuritytoken.serviceprincipalname(v=vs.110).aspx) nicely describes the format as [`host/<hostname>@<domain> or <hostname>`, where hostname is the name of the computer hosting the target Web service and domain is the fully-qualified domain name of the Kerberos realm in which the host computer resides.](https://msdn.microsoft.com/en-us/library/system.identitymodel.tokens.kerberosrequestorsecuritytoken.serviceprincipalname(v=vs.110).aspx) So if you have any issues with Kerberoasting across trusts (particularly external and forest trusts), try using the `SERVICE/host.domain.com@domain.com` format and you may have more success. This is possible with PowerView’s Get-DomainSPNTicket, the function that Invoke-Kerberoast is built on.
# 12. SID Filtering
- **SID**
	- The **SID (Security Identifier)** is a unique identifier that is assigned to each security principal (e.g. user, group, computer). It is used to identify the principal within the domain and is used to control access to resources.
- **SID history**
	- The **SID history** is a property of a user or group object that allows the object to retain its SID when it is migrated from one domain to another as part of a domain consolidation or restructuring. When an object is migrated to a new domain, it is assigned a new SID in the target domain. The SID history allows the object to retain its original SID, so that access to resources in the source domain is not lost.
	- This mechanism can also be abused as a means of persistence: adding the SID of a privileged account or group to the SID-History attribute of a controlled account grants rights associated with account/group of which the SID is added.
	- For instance, the SID of an account with Domain Admin rights can be added to a normal user SID History to grant them Domain Admin rights (the rights would not be granted per say, but the modified account would be treated as domain admin when checking rights).
- **SID Filtering**
	- According to Microsoft, the security boundary in Active Directory is the forest, not the domain. The forest defines the boundaries of trust and controls access to resources within the forest.
	- SID filtering plays an important role in the security boundary by making sure "only SIDs from the trusted domain will be accepted for authorization data returned during authentication. SIDs from other domains will be removed" (`netdom` cmdlet output). By default, SID filtering is disabled for intra-forest trusts, and enabled for inter-forest trusts.
		- if SID filtering is fully enabled, all SIDs that differ from the trusted domain will be filtered out
		- even if it's enabled, a few SIDs will (almost) never be filtered: "Enterprise Domain Controllers" (S-1-5-9) SID and those described by the [trusted domain object (TDO)](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/f2ef15b6-1e9b-48b5-bf0b-019f061d41c8#gt_f2ceef4e-999b-4276-84cd-2e2829de5fc4), as well as seven well-known SIDs (see [MS-PAC doc](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/55fc19f2-55ba-4251-8a6a-103dd7c66280), and [improsec's blogpost](https://improsec.com/tech-blog/sid-filter-as-security-boundary-between-domains-part-3-sid-filtering-explained#yui_3_17_2_1_1673614140169_543)).
		- there are two kinds of inter-forest trusts: "Forest", and "External" (see [trust types](/ad/movement/trusts#trust-types)). Microsoft says "[cross-forest trusts are more stringently filtered than external trusts](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/81d92bba-d22b-4a8c-908a-554ab29148ab?redirectedfrom=MSDN)", meaning that in External trusts, SID filtering only filters out RID < 1000.
	- The SID filtering status of a trust depends on the [trustAttributes](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e9a2d23c-c31e-4a6f-88a0-6646fdb51a3c) flags of a [TDO](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/b645c125-a7da-4097-84a1-2fa7cea07714#gt_f2ceef4e-999b-4276-84cd-2e2829de5fc4) as well as the type of trust.
		- If the `TRUST_ATTRIBUTE_QUARANTINED_DOMAIN (0x00000004)` flag is set, then only SIDs from the trusted domain are allowed (all others are filtered)
		- If the `TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL (0x00000040)` flag is set, then inter-forest ticket can be forged, spoofing an RID >= 1000. Of course, this doesn't apply if TAQD (`TRUST_ATTRIBUTE_QUARANTINED_DOMAIN`) is set.
- The forest is the trust boundary in Active Directory, not the domain. A big part of this is the security protection I’ve alluded to several times previously called SID Filtering. The best reference for SID filtering is the [MS-PAC] “[Privilege Attribute Certificate Data Structure](https://msdn.microsoft.com/en-us/library/cc237917.aspx)” documentation, specifically section [4.1.2.2 SID Filtering and Claims Transformation.](https://msdn.microsoft.com/en-us/library/cc237940.aspx)
- When a user’s TGT is presented to the new domain through a referral, that TGT contains a privileged attribute certificate (PAC) that contains, among other things, the user’s security identifier (SID), the security identifiers of groups they are in, and anything present in the previously discussed sidHistory field (i.e. the **ExtraSids** PAC part described in the **Trustpocalypse** section). This security identification information in the PAC is parsed and analyzed by a _trusting_ domain, and various filters are executed depending on the type of the trust.
- SIDs matching particular patterns are rejected by the trusting domain under various circumstances, as a security protection. SID filtering is meant to stop malicious users with elevated credentials in a _trusted_ domain/forest from taking control of a _trusting_ domain/forest. This is also described in Microsoft’s “[Security Considerations for Trusts](https://technet.microsoft.com/en-us/library/cc755321(v=ws.10).aspx)” documentation.
- There is a set of SIDs that are set to AlwaysFilter, meaning they are always filtered out by a trusting domain, no matter the trust type. The main SID we’re interested in, Enterprise Admins (S-1–5–21-Domain-519), the one that allows us to execute the sidHistory-hopping attack, is set to ForestSpecific for filtering. As Microsoft describes, [The ForestSpecific rule is for those SIDs that are never allowed in a PAC that originates from out of the forest or from a domain that has been marked as QuarantinedWithinForest, unless it belongs to that domain.](https://msdn.microsoft.com/en-us/library/cc237940.aspx) Again, this explains why the forest is the trust boundary, not the domain, as this elevated SID (along with many others) can not be passed across a trust boundary except if the target domain is within the same forest.
- QuarantinedWithinForest, huh? It so happens that domains within a forest can be set as quarantined, which implements a version SID filtering for the domain, even though it is within the forest. However, as the documentation states, [The only SIDs that are allowed to be passed from such a domain are the Enterprise Domain Controllers (S-1–5–9) SID and those described by the trusted domain object (TDO).](https://msdn.microsoft.com/en-us/library/cc237940.aspx) So, since the Enterprise Domain Controllers SID is NOT filtered out for intra-forest quarantined domains, there is still a way to “hop up” the forest trust chain and compromise the forest root.
# 13. Bastion Forests
- Microsoft [introduced](https://docs.microsoft.com/en-us/windows-server/identity/whats-new-active-directory-domain-services#a-namebkmkpamaprivileged-access-management) Privileged Access Management (PAM) with Server 2016. Among other things, it has very interesting features like -  
	- A bastion forest (Think the administrative forest in [ESAE](https://docs.microsoft.com/en-us/windows-server/identity/securing-privileged-access/securing-privileged-access-reference-material#ESAE_BM) or the famous Red Forest)  
	- Shadow security principals  
	- Temporary group membership (Add a user to a group with time-to-live (TTL))
- PAM has been discussed in much detail [here by Russel](https://www.petri.com/windows-server-2016-set-privileged-access-management) and [here by Willem](https://blogs.technet.microsoft.com/389thoughts/2017/06/19/ad-2016-pam-trust-how-it-works-and-safety-advisory/). Please read them for understanding what PAM has to offer. A quick explanation is below:  
  - In a perfect world, PAM enables managing an existing production/user forest using a bastion forest which has a one-way PAM trust with the existing forest. The users in the bastion forest can be 'mapped' to privileges groups like Domain Admins and Enterprise Admins in the user forest without modifying any group memberships or ACLs. This is done by creating Shadow security principals in the bastion forest, which are mapped to SIDs for high privilege groups in the user forest and then add users from the admin forest as members of the shadow security principals.
  - Shadow Principals reside in a special container 'CN=Shadow Principal Configuration,CN=Services' under the Configuration container on bastion forest.
  - Now, it is possible to manage powershell.local forest from bastion.local without making any changes in the group memberships or ACLs on powershell.local.  
  - This looks great! This takes away administrative overhead of managing groups and ACLs and reduces chances of lateral movement techniques like OverPTH, PTT and other credential relay techniques.  
  - Now, there is something worth noticing about the above setup. To be able to use the shadow security principals, we had to allow SIDHistory in the PAM trust which means no [SID Filtering](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc755321(v=ws.10)#sid-filtering).
  - A PAM trust where you do not have an isolated bastion forest is disastrous. Why? Because in such a case if we compromise the bastion forest we get high privileges (Enterprise Admins or Domain Admins) in the other forest:
	- There is no group membership (unlike Foreign Security Principals)  
	- No ACLs modification  
	- No other modification to look for in the forest which gets compromised!
### Enumeration
- Using the [ADModule](https://github.com/samratashok/ADModule), we can simply run Get-ADTrust and look for a trust which has ForestTransitive set to True and SIDFilteringQuarantined set to False - this means that SID Filtering is disabled.
`Get-ADTrust -Filter {(ForestTransitive -eq $True) -and (SIDFilteringQuarantined -eq $False)}`
- If you want to enumerate if your current forest is managed by a bastion forest (Blue Teams take note), look for ForestTransitive set to True and SIDFilteringForestAware set to True. In this case, [TrustAttributes](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e9a2d23c-c31e-4a6f-88a0-6646fdb51a3c) is also a very good indicator. It is 0x00000400 (1024 in decimal) for PAM/PIM trust. Simplifying it, it is 1096 for PAM + External Trust + Forest Transitive.
- To enumerate the shadow security principals, its members from the current (bastion) forest and privileges in the user/production forest, we can use the following command from the ActiveDirectory module:
`Get-ADObject -SearchBase ("CN=Shadow Principal Configuration,CN=Services," + (Get-ADRootDSE).configurationNamingContext) -Filter * -Properties * | select Name,member,msDS-ShadowPrincipalSid | fl`
- The following properties are the most interesting ones:  
	- **Name** - Name of the shadow principal  
	- **member** - Members from the bastion forest which are mapped to the shadow principal. In our example, it is the Domain Administrator of defensiveps.local.  
	- **msDS-ShadowPrincipalSid** - The SID of the principal (user or group) in the user/prodcution forest whose privileges are assgined to the shadow security principal. In our example, it is the Enterpise Admins group in the user forest.
### Abusing the shadow principals
- If we compromise the user listed in "member" above we can use the shadow principals.
- With the privileges achieved using shadow principals above, we can access the user forest using RDP (explicit credentials of the bastion user required), WMI, PowerShell Remoting etc. Please note that if Kerberos AES Encryption is not enabled for the PAM trust, we need to add the machines of existing forest in **WSMan** `TrustedHosts` and use `-Authentication Negotiate` option with PowerShell remoting cmdlets.
- Please note that we can also use `SIDHistory` injection using **Mimikatz** to abuse the PAM trust.
### Persistence
- We can also use this for persistence. Please note that the persistence will be for the privileges on the user/prodcution forest and not the bastion forest itself.   
- Once we have compromised the bastion forest, there are multiple ways we can use:  
	1. We can add a user to an existing shadow security principal container.
		`Set-ADObject -Identity "CN=psforest-ShadowEnterpriseAdmin,CN=Shadow Principal Configuration,CN=Services,CN=Configuration,DC=defensiveps,DC=local" -Add @{'member'="CN=lowpriv user,CN=Users,DC=defensiveps,DC=local"} -Verbose`
	- Please note that in this case, if someone looks at the details of the 'lowprivuser', he/she would appear to be a part of the psforest-ShadowEnterpriseAdmin 'group'.
	2. Better, we can modify the ACL of the shadow principal object. We can provide a user we control, Full Permission overt shadow principal object but the fun is always with [minimal permissions](https://www.labofapenetrationtester.com/2018/04/dcshadow.html). So, with only Read Members and Write Members permissions on the shadow principal object, we can add and remove principals at will from the shadow principals. Now, we can add or remove users at will with the privileges of 'reportdbadmin' user. On top of that, by-default there are no logs for any changes to the ACL or 'membership' of a shadow principal.
# 14. Cheatsheet
### Intra-Forest Cross-Domain Trust Abuse (Different Domains inside the Same Forest)
- Do we have DA privileges on a domain **INSIDE** the forest?
	- YES -> we can elevate our privileges to EA using the following methods:
		- Abusing Parent-Child Trust Relationship to forge an Inter-Realm Golden Ticket. We need the `krbtgt` credentials of the compromised domain.
		  `.\Rubeus.exe golden /rc4:b0975ae49f441adc6b024ad238935af5 /domain:us.techcorp.local /sid:S-1-5-21-210670787-2521448726-163245708 /sids:S-1-5-21-2781415573-3701854478-2406986946-519 /user:Administrator /ptt /nowrap`
		- Abusing the Trust Keys to forge an Inter-Realm Golden Ticket. We need the `targetdomain$` credentials of the compromised domain.
		  `.\Rubeus.exe golden /rc4:86d1ec8e8407e8065b6b49e27230e90f /domain:us.techcorp.local /sid:S-1-5-21-210670787-2521448726-163245708 /sids:S-1-5-21-2781415573-3701854478-2406986946-519 /user:Administrator /service:krbtgt /target:techcorp.local /nowrap`
		- Abusing the KUD of the compromised domain's DC (or other machine with similar privileges) and coercing the target domain's DC to authenticate to it using `PrinterBug` to steal the TGT of the target DC's machine account.
			- Monitor for tickets at the compromised DC: `.\Rubeus.exe monitor /interval:5 /targetuser:techcorp-dc$ /nowrap`
			- Coerce the target DC to authenticate to the compromised DC: `.\MS-RPRN.exe \\techcorp-dc.techcorp.local \\us-dc.us.techcorp.local`
	- NO
		- Use `Get-DomainForeignUser` to find whether any user from our domain has access into other groups in the forest.
		- Use `Get-DomainForeignGroupMember -Domain OTHER.DOMAIN` to see if groups in those other forest domains had “incoming” access.
		- Kerberoasting
		  `.\Rubeus kerberoast /domain:eu.local /nowrap`
### Inter-Forest Cross-Domain Attack (Different Domains in Different Forests)
#### Bidirectional Inter-Forest Cross-Domain Attack (`FOREST_TRANSITIVE`, `Bidirectional`)
- In that specific case, **THE FOREST IS NOT A SECURITY BOUNDARY**.
- We may be able to abuse the KUD of the compromised domain's DC (or other machine with similar privileges) and coercing the target domain's DC to authenticate to it using `PrinterBug` to steal the TGT of the target DC's machine account.
	- Monitor for tickets at the compromised DC: `.\Rubeus.exe monitor /interval:5 /targetuser:usvendor-dc$ /nowrap`
	- Coerce the target DC to authenticate to the compromised DC: `.\MS-RPRN.exe \\usvendor-dc.usvendor.local \\techcorp-dc.techcorp.local`
#### Bidirectional Inter-Forest Cross-Domain Attack with Fully Implemented SID Filtering (`FILTER_SIDS`, `Bidirectional`)
- Enumerate for Local Group Membership on individual servers.
- Enumerate for Foreign Security Principals on the target domain: `Get-DomainForeignGroupMember -Domain OTHER.DOMAIN`
- Enumerate for Foreign ACL Principals:
  `Find-InterestingDomainAcl -Domain OTHER.DOMAIN -ResolveGUIDs`
- Kerberoasting
  `.\Rubeus kerberoast /domain:eu.local /nowrap`
#### One-Way Inter-Forest Cross-Domain Attack (`FOREST_TRANSITIVE`, `Inbound`)
- Enumerate for Local Group Membership on individual servers.
- Enumerate for Foreign Security Principals on the target domain: `Get-DomainForeignGroupMember -Domain OTHER.DOMAIN`
- Enumerate for Foreign ACL Principals:
  `Find-InterestingDomainAcl -Domain OTHER.DOMAIN -ResolveGUIDs`
- Kerberoasting
  `.\Rubeus kerberoast /domain:eu.local /nowrap`
#### Bidirectional External Cross-Domain Attack with SID Filtering (`TREAT_AS_EXTERNAL,FOREST_TRANSITIVE`, `Bidirectional`)
- Enumerate for Local Group Membership on individual servers.
- Enumerate for Foreign Security Principals on the target domain: `Get-DomainForeignGroupMember -Domain OTHER.DOMAIN`
- Enumerate for Foreign ACL Principals:
  `Find-InterestingDomainAcl -Domain OTHER.DOMAIN -ResolveGUIDs`
- Kerberoasting
  `.\Rubeus kerberoast /domain:eu.local /nowrap`
- Find Interesting Domain Groups with `SID-extention>1000` that could be used for `SID History` injection, in order to obtain the privileges of that group on the target domain. In order to abuse that, we will need the `targetdomain$` credentials of the compromised domain.
  `.\Rubeus.exe golden /rc4:629b1eaa7ec6cfe2f4943a853ad6b36b /domain:eu.local /sid:S-1-5-21-3657428294-2017276338-1274645009 /sids:S-1-5-21-4066061358-3942393892-617142613-1103 /user:Administrator /service:krbtgt /target:euvendor.local /nowrap`
#### Bastion Forests
- Look for a way to compromise the **Bastion (Red)** forest in order to easily gain access over all the managed Production forests.